package environment

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"net"
	"net/netip"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/canonical/lxd/shared/logger"
	"github.com/canonical/microcluster/v2/cluster"
	"github.com/canonical/microcluster/v2/state"

	"github.com/canonical/microovn/microovn/database"
	"github.com/canonical/microovn/microovn/ovn/certificates"
	"github.com/canonical/microovn/microovn/ovn/paths"
)

var ovnEnvTpl = template.Must(template.New("ovnEnvTpl").Parse(`# # Generated by MicroOVN, DO NOT EDIT.
OVN_INITIAL_NB="{{ .nbInitial }}"
OVN_INITIAL_SB="{{ .sbInitial }}"
OVN_NB_CONNECT="{{ .nbConnect }}"
OVN_SB_CONNECT="{{ .sbConnect }}"
OVN_LOCAL_IP="{{ .localAddr }}"
`))

// NetworkProtocol returns appropriate network protocol that should be used
// by OVN services.
func NetworkProtocol(ctx context.Context, s state.State) string {
	_, _, err := certificates.GetCA(ctx, s)
	if err != nil {
		return "tcp"
	}
	return "ssl"
}

// ConnectionString builds a string that defines connection endpoints of OVN
// cluster services. It can be used to tell services (i.e. ovn-controller) about
// the location of OVN central services.
// Example return value: "ssl:10.0.0.1:6641,ssl:10.0.0.2:6641,ssl:10.0.0.3:6641"
func ConnectionString(ctx context.Context, s state.State, port int) (string, string, error) {
	var err error
	var servers []database.Service
	var clusterMap map[string]cluster.CoreClusterMember
	err = s.Database().Transaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
		serviceName := "central"
		servers, err = database.GetServices(ctx, tx, database.ServiceFilter{Service: &serviceName})
		if err != nil {
			return err
		}

		clusterMembers, err := cluster.GetCoreClusterMembers(ctx, tx)
		if err != nil {
			return err
		}

		clusterMap = make(map[string]cluster.CoreClusterMember, len(clusterMembers))
		for _, clusterMember := range clusterMembers {
			clusterMap[clusterMember.Name] = clusterMember
		}

		return nil
	})
	if err != nil {
		return "", "", err
	}

	addresses := make([]string, 0, len(servers))
	var initialString string
	protocol := NetworkProtocol(ctx, s)
	for i, server := range servers {
		member := clusterMap[server.Member]
		memberAddr, err := netip.ParseAddrPort(member.Address)
		if err != nil {
			return "", "", err
		}

		if i == 0 {
			initialString = memberAddr.Addr().String()
			if memberAddr.Addr().Is6() {
				initialString = "[" + initialString + "]"
			}
		}

		addresses = append(
			addresses,
			fmt.Sprintf("%s:%s",
				protocol,
				net.JoinHostPort(memberAddr.Addr().String(), strconv.Itoa(port)),
			),
		)
	}

	return strings.Join(addresses, ","), initialString, nil
}

// GenerateEnvironment generates the OVN environment file.
func GenerateEnvironment(ctx context.Context, s state.State) error {
	// Get the servers.
	nbConnect, nbInitial, err := ConnectionString(ctx, s, 6641)
	if err != nil {
		return err
	}

	sbConnect, sbInitial, err := ConnectionString(ctx, s, 6642)
	if err != nil {
		return err
	}

	// Generate ovn.env.
	fd, err := os.OpenFile(paths.OvnEnvFile(), os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0644)
	if err != nil {
		return fmt.Errorf("couldn't open ovn.env: %w", err)
	}
	defer fd.Close()

	localAddr := s.Address().Hostname()
	if ip, err := netip.ParseAddr(localAddr); err == nil && ip.Is6() {
		localAddr = "[" + localAddr + "]"
	}

	//set northbound to be at the local address if there is no central db found
	if nbInitial == "" {
		nbInitial = localAddr
	}
	if nbConnect == "" {
		nbConnect = "ssl:" + localAddr + ":6641"
	}

	//set southbound to be at the local address if there is no central db found
	if sbInitial == "" {
		sbInitial = localAddr
	}
	if sbConnect == "" {
		sbConnect = "ssl:" + localAddr + ":6642"
	}

	err = ovnEnvTpl.Execute(fd, map[string]any{
		"localAddr": localAddr,
		"nbInitial": nbInitial,
		"sbInitial": sbInitial,
		"nbConnect": nbConnect,
		"sbConnect": sbConnect,
	})
	if err != nil {
		return fmt.Errorf("couldn't render ovn.env: %w", err)
	}

	return nil
}

// CreatePaths creates the required directories for OVN.
func CreatePaths() error {
	// Create our various paths.
	for _, path := range paths.RequiredDirs() {
		err := os.MkdirAll(path, 0700)
		if err != nil {
			return fmt.Errorf("unable to create %q: %w", path, err)
		}
	}

	return nil
}

// CleanupPaths backs up directories defined by paths.BackupDirs and then removes directories
// created by CreatePaths function. This effectively removes any data created during MicroOVN runtime.
func CleanupPaths() error {
	var errs []error

	// Create timestamped backup dir
	backupDir := fmt.Sprintf("backup_%d", time.Now().Unix())
	backupPath := filepath.Join(paths.Root(), backupDir)
	err := os.Mkdir(backupPath, 0750)
	if err != nil {
		errs = append(
			errs,
			fmt.Errorf(
				"failed to create backup directory '%s', refusing to continue with data removal: %s",
				backupPath,
				err,
			),
		)
		return errors.Join(errs...)
	}

	// Backup selected directories
	for _, dir := range paths.BackupDirs() {
		_, fileName := filepath.Split(dir)
		destination := filepath.Join(backupPath, fileName)
		err = os.Rename(dir, destination)
		if err != nil {
			errs = append(errs, err)
		}
	}

	// Return if any backups failed
	if len(errs) > 0 {
		errs = append(
			errs,
			fmt.Errorf("failures occured during backup, refusing to continue with data removal"),
		)
		return errors.Join(errs...)
	}
	logger.Infof("MicroOVN data backed up to %s", backupPath)

	// Remove rest of the directories
	for _, dir := range paths.RequiredDirs() {
		err = os.RemoveAll(dir)
		if err != nil {
			errs = append(errs, fmt.Errorf("failed to remove directory '%s': %w", dir, err))
		}
	}

	return errors.Join(errs...)
}
