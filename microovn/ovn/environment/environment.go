package environment

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"net"
	"net/netip"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"text/template"
	"time"

	"github.com/canonical/lxd/shared/logger"
	"github.com/canonical/microcluster/v3/state"

	"github.com/canonical/microovn/microovn/config"
	"github.com/canonical/microovn/microovn/database"
	"github.com/canonical/microovn/microovn/ovn/certificates"
	"github.com/canonical/microovn/microovn/ovn/paths"
)

var ovnEnvTpl = template.Must(template.New("ovnEnvTpl").Parse(`# # Generated by MicroOVN, DO NOT EDIT.
OVN_INITIAL_NB="{{ .nbInitial }}"
OVN_INITIAL_SB="{{ .sbInitial }}"
OVN_NB_CONNECT="{{ .nbConnect }}"
OVN_SB_CONNECT="{{ .sbConnect }}"
OVN_LOCAL_IP="{{ .localAddr }}"
`))

// NetworkProtocol returns appropriate network protocol that should be used
// by OVN services.
func NetworkProtocol(ctx context.Context, s state.State) string {
	_, _, err := certificates.GetCA(ctx, s)
	if err != nil {
		return "tcp"
	}
	return "ssl"
}

// IsExternalCentralConfigured returns True if the config option "ovn.central-ips" was explicitly configured
func IsExternalCentralConfigured(ctx context.Context, s state.State) (bool, error) {
	ovnRemoteConfig, err := config.GetConfig(ctx, s, "ovn.central-ips")
	if err != nil {
		return false, err
	}
	return ovnRemoteConfig != nil, nil
}

// remoteAddressesFromConfig attempts to retrieve a list of IP addresses that should be used for
// connecting to ovn-central services from the config option "ovn.central-ips". The return value is nil
// if the config option is not set in the database.
func remoteAddressesFromConfig(ctx context.Context, s state.State) ([]string, error) {
	ovnRemoteConfig, err := config.GetConfig(ctx, s, "ovn.central-ips")
	if err != nil {
		return nil, err
	}

	if ovnRemoteConfig == nil {
		return nil, nil
	}

	return strings.Split(ovnRemoteConfig.Value, ","), nil

}

// defaultRemoteAddresses generates a list of IP addresses that should be used for connecting to ovn-central services
// by returning addresses of MicroOVN cluster members with service "central" enabled.
func defaultRemoteAddresses(ctx context.Context, s state.State) ([]string, error) {
	var addrList []string
	err := s.Database().Transaction(ctx, func(ctx context.Context, tx *sql.Tx) error {
		serviceName := "central"
		servers, err := database.GetServices(ctx, tx, database.ServiceFilter{Service: &serviceName})
		if err != nil {
			return err
		}

		// Query core cluster members directly from the database
		rows, err := tx.QueryContext(ctx, "SELECT name, address FROM core_cluster_members")
		if err != nil {
			return err
		}
		defer rows.Close()

		for rows.Next() {
			var name, address string
			if err := rows.Scan(&name, &address); err != nil {
				return err
			}

			for _, server := range servers {
				if server.Member == name {
					parsedAddr, err := netip.ParseAddrPort(address)
					if err != nil {
						return err
					}
					// address is a string containing an IP address and a Port.
					// We need to parse it into a raw address string
					addrList = append(addrList, parsedAddr.Addr().String())
					break
				}
			}
		}

		return rows.Err()
	})
	return addrList, err
}

// CentralIps returns a list of IP addresses of OVN central services. This function
// primarily returns addresses configured via the "ovn.central-ips" config option
// and falls back to IP addresses of MicroOVN nodes with "central" service enabled
// if the config option is not set.
func CentralIps(ctx context.Context, s state.State) ([]string, error) {
	// Attempt to primarily get the list of ovn-central node IPs from the config.
	addrList, err := remoteAddressesFromConfig(ctx, s)
	if err != nil {
		return nil, err
	}

	// If the option was not set, fall back to using MicroOVN nodes with "central" service enabled
	if addrList == nil {
		addrList, err = defaultRemoteAddresses(ctx, s)
		if err != nil {
			return nil, err
		}
	}

	return addrList, nil
}

// initialNbSbHost returns an IP address or a hostname that should be used by
// a Northbound and Southbound database to connect to the rest of the cluster.
func initialNbSbHost(s state.State, addrList []string) (string, error) {
	var initialNode string
	localAddr := s.Address().Hostname()

	// With only a single central node enabled, there are no other cluster members to connect to.
	// Setting the "initial node" to the address of the only node with the central enabled will
	// cause the NB/SB databases to be initialized on that node.
	if len(addrList) == 1 {
		initialNode = addrList[0]
	}

	// With more than one node in the central cluster, we set the value of the "initial node" to
	// point to any non-local node that runs the central service. This will allow the NB/SB databases
	// to join the existing cluster via the remote node.
	for _, addr := range addrList {
		if initialNode == "" && addr != localAddr {
			initialNode = addr
			break
		}
	}

	if strings.Contains(initialNode, ":") {
		initialNode = "[" + initialNode + "]"
	}

	return initialNode, nil
}

// ConnectionString builds strings that define connection endpoints of OVN
// cluster services. Its return value can be used to tell processes (i.e. ovn-controller)
// about the location of OVN central services.
// Example: "ssl:10.0.0.1:6641,ssl:10.0.0.2:6641,ssl:10.0.0.3:6641"
func ConnectionString(ctx context.Context, s state.State, addrList []string, port int) (string, error) {
	// Transform the list of bare IP addresses into the format understood by the OVN, "<protocol>:<IP>:<PORT>"
	addresses := make([]string, 0, len(addrList))
	protocol := NetworkProtocol(ctx, s)
	for _, nodeAddress := range addrList {
		addresses = append(
			addresses,
			fmt.Sprintf("%s:%s",
				protocol,
				net.JoinHostPort(nodeAddress, strconv.Itoa(port)),
			),
		)
	}

	return strings.Join(addresses, ","), nil
}

// GenerateEnvironment generates the OVN environment file.
func GenerateEnvironment(ctx context.Context, s state.State) error {
	centralIps, err := CentralIps(ctx, s)
	if err != nil {
		return fmt.Errorf("failed to get OVN central IPs: %w", err)
	}

	nbConnect, err := ConnectionString(ctx, s, centralIps, 6641)
	if err != nil {
		return err
	}

	sbConnect, err := ConnectionString(ctx, s, centralIps, 6642)
	if err != nil {
		return err
	}

	initialNbSb, err := initialNbSbHost(s, centralIps)
	if err != nil {
		return err
	}

	// Generate ovn.env.
	fd, err := os.OpenFile(paths.OvnEnvFile(), os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0644)
	if err != nil {
		return fmt.Errorf("couldn't open ovn.env: %w", err)
	}
	defer fd.Close()

	localAddr := s.Address().Hostname()
	if ip, err := netip.ParseAddr(localAddr); err == nil && ip.Is6() {
		localAddr = "[" + localAddr + "]"
	}

	err = ovnEnvTpl.Execute(fd, map[string]any{
		"localAddr": localAddr,
		"nbInitial": initialNbSb,
		"sbInitial": initialNbSb,
		"nbConnect": nbConnect,
		"sbConnect": sbConnect,
	})
	if err != nil {
		return fmt.Errorf("couldn't render ovn.env: %w", err)
	}

	return nil
}

// CreatePaths creates the required directories for OVN.
func CreatePaths() error {
	// Create our various paths.
	for _, path := range paths.RequiredDirs() {
		err := os.MkdirAll(path, 0700)
		if err != nil {
			return fmt.Errorf("unable to create %q: %w", path, err)
		}
	}

	return nil
}

// CleanupPaths backs up directories defined by paths.BackupDirs and then removes directories
// created by CreatePaths function. This effectively removes any data created during MicroOVN runtime.
func CleanupPaths() error {
	var errs []error

	// Create timestamped backup dir
	backupDir := fmt.Sprintf("backup_%d", time.Now().Unix())
	backupPath := filepath.Join(paths.Root(), backupDir)
	err := os.Mkdir(backupPath, 0750)
	if err != nil {
		errs = append(
			errs,
			fmt.Errorf(
				"failed to create backup directory '%s', refusing to continue with data removal: %s",
				backupPath,
				err,
			),
		)
		return errors.Join(errs...)
	}

	// Backup selected directories
	for _, dir := range paths.BackupDirs() {
		_, fileName := filepath.Split(dir)
		destination := filepath.Join(backupPath, fileName)
		err = os.Rename(dir, destination)
		if err != nil {
			errs = append(errs, err)
		}
	}

	// Return if any backups failed
	if len(errs) > 0 {
		errs = append(
			errs,
			fmt.Errorf("failures occured during backup, refusing to continue with data removal"),
		)
		return errors.Join(errs...)
	}
	logger.Infof("MicroOVN data backed up to %s", backupPath)

	// Remove rest of the directories
	for _, dir := range paths.RequiredDirs() {
		err = os.RemoveAll(dir)
		if err != nil {
			errs = append(errs, fmt.Errorf("failed to remove directory '%s': %w", dir, err))
		}
	}

	return errors.Join(errs...)
}
