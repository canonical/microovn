package ovn

import (
	"context"
	"database/sql"
	"fmt"
	"net/netip"
	"os"
	"strings"
	"text/template"

	"github.com/canonical/microcluster/state"

	"github.com/canonical/microovn/microovn/database"
	"github.com/canonical/microovn/microovn/ovn/paths"
)

var ovnEnvTpl = template.Must(template.New("ovnEnvTpl").Parse(`# # Generated by MicroOVN, DO NOT EDIT.
OVN_INITIAL_NB="{{ .nbInitial }}"
OVN_INITIAL_SB="{{ .sbInitial }}"
OVN_NB_CONNECT="{{ .nbConnect }}"
OVN_SB_CONNECT="{{ .sbConnect }}"
OVN_LOCAL_IP="{{ .localAddr }}"
`))

func connectString(s *state.State, port int) (string, error) {
	var err error
	var servers []database.Service

	err = s.Database.Transaction(s.Context, func(ctx context.Context, tx *sql.Tx) error {
		serviceName := "central"
		servers, err = database.GetServices(ctx, tx, database.ServiceFilter{Service: &serviceName})
		if err != nil {
			return err
		}

		return nil
	})
	if err != nil {
		return "", err
	}

	addresses := make([]string, len(servers))
	remotes := s.Remotes().RemotesByName()
	for i, server := range servers {
		remote, ok := remotes[server.Member]
		if !ok {
			continue
		}

		addresses[i] = fmt.Sprintf("tcp:%s",
			netip.AddrPortFrom(remote.Address.Addr(), uint16(port)).String())
	}

	return strings.Join(addresses, ","), nil
}

func generateEnvironment(s *state.State) error {
	// Get the servers.
	nbConnect, err := connectString(s, 6641)
	if err != nil {
		return err
	}

	sbConnect, err := connectString(s, 6642)
	if err != nil {
		return err
	}

	// Get the initial (first server).
	var nbInitial string
	var sbInitial string
	err = s.Database.Transaction(s.Context, func(ctx context.Context, tx *sql.Tx) error {
		serviceName := "central"
		servers, err := database.GetServices(ctx, tx, database.ServiceFilter{Service: &serviceName})
		if err != nil {
			return err
		}

		server := servers[0]

		remotes := s.Remotes().RemotesByName()
		remote, ok := remotes[server.Member]
		if !ok {
			return fmt.Errorf("Remote couldn't be found for %q", server.Member)
		}

		addrString := remote.Address.Addr().String()
		if remote.Address.Addr().Is6() {
			addrString = "[" + addrString + "]"
		}

		nbInitial = addrString
		sbInitial = addrString

		return nil
	})
	if err != nil {
		return err
	}

	// Generate ovn.env.
	fd, err := os.OpenFile(paths.OvnEnvFile(), os.O_CREATE|os.O_TRUNC|os.O_RDWR, 0644)
	if err != nil {
		return fmt.Errorf("Couldn't open ovn.env: %w", err)
	}
	defer fd.Close()

	localAddr := s.Address().Hostname()
	if ip, err := netip.ParseAddr(localAddr); err == nil && ip.Is6() {
		localAddr = "[" + localAddr + "]"
	}

	err = ovnEnvTpl.Execute(fd, map[string]any{
		"localAddr": localAddr,
		"nbInitial": nbInitial,
		"sbInitial": sbInitial,
		"nbConnect": nbConnect,
		"sbConnect": sbConnect,
	})
	if err != nil {
		return fmt.Errorf("Couldn't render ovn.env: %w", err)
	}

	return nil
}

func createPaths() error {
	// Create our various paths.
	for _, path := range paths.RequiredDirs() {
		err := os.MkdirAll(path, 0700)
		if err != nil {
			return fmt.Errorf("Unable to create %q: %w", path, err)
		}
	}

	return nil
}
