name: Tests
on:
  push:
    branches: [main]
  pull_request:
  schedule:
    - cron: '14 3 * * 1'
  workflow_dispatch:

jobs:
  lint:
    name: lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt install shellcheck

      - name: Lint
        run: |
          make check-lint

      - name: Ensure go.mod is up to date
        run: |
          set -euxo pipefail
          # The Launchpad build pipeline will run `go mod tidy`.
          #
          # Consequently a rebuild could produce a `-dirty` version string if
          # any of our dependencies have changed.
          #
          # While annoying, it is actually a nice feature, because we do want
          # to make concious choices about updates to our dependencies.
          #
          # Check whether a `go mod tidy` would cause go.mod to change and fail
          # if it does.
          assert_git_status() {
              local files="go.mod go.sum"
              if [ -n "$(git status --porcelain=v2 $files)" ]; then
                  echo "files NOT in sync with git: $files"
                  git status $files
                  exit 1
              else
                  echo "files in sync with git: $files"
              fi
          }

          cd microovn
          assert_git_status
          go mod tidy -v -x
          assert_git_status

  build:
    name: build
    needs:
      - lint
    runs-on: ubuntu-latest
    env:
      MICROOVN_SNAP: microovn.snap
      MICROOVN_IMAGE: microovn-lxd-template.tar.gz
      MICROOVN_UNSQUASH_DST: ${{ github.workspace }}/microovn-squashfs
      # The `base_ref` will only be set for PR and contain the name of the
      # target branch.  The `ref_name` will be correct for the final push
      # check after a PR is merged.
      #
      # This setup may lead to failures on push to arbitrarily named branches
      # on a fork, but that is a price worth paying.
      #
      # Contributors can raise a draft PR to get accurate results.
      POSSIBLE_TARGET_BRANCH: "${{ github.base_ref || github.ref_name }}"
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Clear FORWARD firewall rules
        run: |
          # Docker can inject rules causing firewall conflicts
          sudo iptables -P FORWARD ACCEPT  || true
          sudo ip6tables -P FORWARD ACCEPT || true
          sudo iptables -F FORWARD  || true
          sudo ip6tables -F FORWARD || true

      - name: Install dependencies
        run: |
          sudo snap refresh
          sudo snap install lxd
          sudo snap set lxd daemon.group=adm
          sudo lxd init --auto
          test $POSSIBLE_TARGET_BRANCH = main && \
              export SNAPCRAFT_CHANNEL=latest/edge
          sudo snap install snapcraft \
              --channel "${SNAPCRAFT_CHANNEL:-latest/stable}" \
              --classic

      - name: Build snap and LXD image
        run: |
          # Build snap with coverage support
          sed -i 's/MICROOVN_COVERAGE=.*/MICROOVN_COVERAGE="yes"/g' microovn/build-aux/environment
          make $MICROOVN_IMAGE

      - name: Upload Snap
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: snaps
          path: ${{ env.MICROOVN_SNAP }}
          retention-days: 5

      - name: Upload LXD image
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: lxd-image
          path: ${{ env.MICROOVN_IMAGE }}
          retention-days: 5

      - name: Extract unit test coverage
        run: |
          unsquashfs -dest ${{ env.MICROOVN_UNSQUASH_DST}} ${{ env.MICROOVN_SNAP }} .coverage

      - name: Upload unit test coverage
        uses: actions/upload-artifact@v4
        with:
          name: unit_test_coverage
          path: ${{ env.MICROOVN_UNSQUASH_DST }}/.coverage
          include-hidden-files: true
          retention-days: 1

  metadata:
    name: Generate matrix
    needs:
      - build
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.generate-matrix.outputs.matrix }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Generate matrix
        id: generate-matrix
        run: |
          MATRIX_JSON="{\"test-file\": ["
          TEST_FILES=( $(cd tests; ls -1 *.bats) )
          for (( i=0 ; i < "${#TEST_FILES[@]}"; i++ )); do
              if [ $i -gt 0 ]; then
                  MATRIX_JSON+=","
              fi
              MATRIX_JSON+="\"${TEST_FILES[$i]}\""
          done
          MATRIX_JSON+="]}"

          echo matrix=${MATRIX_JSON} | tee -a ${GITHUB_OUTPUT}

  system-tests:
    name: System tests
    needs:
      - metadata
    runs-on: ubuntu-latest
    env:
      MICROOVN_SNAP_PATH: ${{ github.workspace }}/microovn.snap
      MICROOVN_SNAP_CHANNEL: 22.03/stable
    strategy:
      matrix: ${{ fromJson(needs.metadata.outputs.matrix) }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Download built snap
        uses: actions/download-artifact@v4
        with:
          name: snaps

      - name: Download built image
        uses: actions/download-artifact@v4
        with:
          name: lxd-image

      - name: Clear FORWARD firewall rules
        run: |
          # Docker can inject rules causing firewall conflicts
          sudo iptables -P FORWARD ACCEPT  || true
          sudo ip6tables -P FORWARD ACCEPT || true
          sudo iptables -F FORWARD  || true
          sudo ip6tables -F FORWARD || true

      - name: Install dependencies
        run: |
          sudo snap refresh
          sudo snap install lxd
          sudo snap set lxd daemon.group=adm
          sudo lxd init --auto
          snap list
          sudo apt install -y linux-modules-extra-$(uname -r)

      - name: Run system tests
        run: MICROOVN_COVERAGE_ENABLED=yes make tests/${{ matrix.test-file }}

      - name: Upload test coverage
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.test-file }}_coverage
          path: ${{ github.workspace }}/.coverage
          include-hidden-files: true
          retention-days: 1

  generate-coverage:
    name: Generate coverage profile
    needs:
      - metadata
      - system-tests
    # 'ubuntu-latest' currently resolves to '22.04' [0] and since we require "Go >=1.20"
    # for coverage tools, we need to use explicit 'ubuntu-24.04' image name.
    # [0] https://github.com/actions/runner-images/issues/10636
    runs-on: ubuntu-24.04
    env:
      COVERAGE_DIR: ${{ github.workspace }}/.coverage
      COVERAGE_MERGED: ${{ github.workspace }}/.coverage/_merged
      COVERAGE_MERGED_PROFILE: ${{ github.workspace }}/.coverage/_merged/profile.out
    steps:
      - name: Install dependencies
        run: |
          sudo apt update
          sudo apt install -yqq golang
          go install github.com/boumenot/gocover-cobertura@v1.2.0

      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download test coverage data
        uses: actions/download-artifact@v4
        with:
          path: ${{ env.COVERAGE_DIR }}
          pattern: "*_coverage"

      - name: Merge test coverage data
        run: |
          mkdir -p "$COVERAGE_MERGED"
          coverage_inputs=$(find "$COVERAGE_DIR" -type d -name coverage | tr '\n' ',' | sed 's/,$//g')
          go tool covdata merge -i="$coverage_inputs" -o="$COVERAGE_MERGED"
          go tool covdata textfmt -i="$COVERAGE_MERGED" -o="$COVERAGE_MERGED_PROFILE"

      - name: Generate cobertura.xml
        run: |
          cd microovn/
          $HOME/go/bin/gocover-cobertura < "$COVERAGE_MERGED_PROFILE" > "$COVERAGE_DIR/cobertura.xml"

      - name: Upload cobertura.xml
        uses: actions/upload-artifact@v4
        with:
          name: cobertura.xml
          path: ${{ env.COVERAGE_DIR }}/cobertura.xml
          include-hidden-files: true

  tics:
    name: Tiobe TICS
    runs-on: [self-hosted, amd64, tiobe, noble]
    env:
      COVERAGE_DIR: ${{ github.workspace }}/.coverage
      SRC_DIR: ${{ github.workspace }}/microovn/
    needs:
      - generate-coverage
    # TICS execution requires access to an auth. token which is not available in the forks of this
    # repository. We allow this job to run only if it has access to the token:
    #  * On "push" action
    #  * On scheduled action
    #  * On pull request created from the main repository (not fork)
    if: ${{ (github.event_name != 'pull_request') || (github.repository == github.event.pull_request.head.repo.full_name) }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: ${{ env.SRC_DIR }}/go.mod

      - name: Install dqlite
        run: |
          sudo apt install -yqq yq
          DQLITE_TAG=$(yq -r '.parts.dqlite."source-tag"' ${{ github.workspace }}/snap/snapcraft.yaml)
          
          git clone --branch "$DQLITE_TAG" --single-branch https://github.com/canonical/dqlite /tmp/dqlite
          sudo apt install -yqq pkg-config autoconf automake libtool make libuv1-dev libsqlite3-dev liblz4-dev
          cd /tmp/dqlite/
          autoreconf -i
          ./configure --enable-build-raft
          sudo make install

      - name: Prepare TICS environment
        run: |
          mkdir -p ${{ env.COVERAGE_DIR }}
          go get -d -v ./...
          go install honnef.co/go/tools/cmd/staticcheck@v0.5.1

        working-directory: ${{ env.SRC_DIR }}

      - name: Download coverage data
        uses: actions/download-artifact@v4
        with:
          name: cobertura.xml
          path: ${{ env.COVERAGE_DIR }}

      # This type of the TICS run creates a persistent measurement point against
      # which we measure subsequent changes. Therefore, it is created only on push to
      # the main branch or during the bi-weekly scheduled runs.
      - name: "Full TICS run (mode: qserver)"
        if: ${{ (github.event_name == 'push') || (github.event_name == 'cron') }}
        uses: tiobe/tics-github-action@v3
        env:
          TICSAUTHTOKEN: ${{ secrets.TICSAUTHTOKEN }}
        with:
          mode: qserver
          project: microovn
          viewerUrl: https://canonical.tiobe.com/tiobeweb/TICS/api/cfg?name=GoProjects
          ticsAuthToken: ${{ secrets.TICSAUTHTOKEN }}
          installTics: true

      # This type of the TICS run compares current state of the code against the last
      # persistent measurement point. We run in on proposed pull requests.
      - name: "Comparative TICS run (mode: client)"
        if: ${{ github.event_name == 'pull_request' }}
        uses: tiobe/tics-github-action@v3
        env:
          TICSAUTHTOKEN: ${{ secrets.TICSAUTHTOKEN }}
        with:
          mode: client
          project: microovn
          viewerUrl: https://canonical.tiobe.com/tiobeweb/TICS/api/cfg?name=GoProjects
          ticsAuthToken: ${{ secrets.TICSAUTHTOKEN }}
          installTics: true
