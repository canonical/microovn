# This is a bash shell fragment -*- bash -*-
load "${ABS_TOP_TEST_DIRNAME}test_helper/setup_teardown/$(basename "${BATS_TEST_FILENAME//.bats/.bash}")"

setup() {
    load ${ABS_TOP_TEST_DIRNAME}test_helper/common.bash
    load ${ABS_TOP_TEST_DIRNAME}test_helper/lxd.bash
    load ${ABS_TOP_TEST_DIRNAME}test_helper/tls.bash
    load ${ABS_TOP_TEST_DIRNAME}test_helper/microovn.bash
    load ${ABS_TOP_TEST_DIRNAME}../.bats/bats-support/load.bash
    load ${ABS_TOP_TEST_DIRNAME}../.bats/bats-assert/load.bash

    # Ensure TEST_CONTAINERS is populated, otherwise the tests below will
    # provide false positive results.
    assert [ -n "$TEST_CONTAINERS" ]
    assert [ -n "$CENTRAL_CONTAINERS" ]
    assert [ -n "$CHASSIS_CONTAINERS" ]

    # Temporary location to be used for uploading user-supplied CA certificate
    # and key inside the MicroOVN container.
    # Note: MicroOVN does not use this location to actually look for the certificate
    export USER_CA_CRT="/var/snap/microovn/common/user-ca.crt"
    export USER_CA_KEY="/var/snap/microovn/common/user-ca.key"

    # CommonName used by the user-supplied test CA cert
    export USER_CA_CN="Test CA"
    # CommonName used by the self-signed CA cert generated by MicroOVN
    # automatically
    export AUTO_CA_CN="MicroOVN CA"
}

teardown() {
    # If tests adjust system time in the VM, they should export
    # RESET_TIME variable. If set, all containers will sync their
    # time with the host
    local container
    if [ -n "$RESET_TIME" ]; then
        local host_time
        host_time="$(date --rfc-3339=seconds)"
        for container in $TEST_CONTAINERS; do
            echo "# Synchronizing time on $container with the host"
            lxc_exec "$container" "timedatectl set-time '$host_time'"
            run lxc_exec "$container" "microovn certificates regenerate-ca"
        done
    fi
    unset RESET_TIME
}

tls_cluster_register_test_functions() {
    bats_test_function \
        --description "OVN central services have enabled TLS" \
        -- tls_cluster_central_have_tls
    bats_test_function \
        --description "Certificates files are valid certificates" \
        -- tls_cluster_certificates_valid
    bats_test_function \
        --description "List certificates on OVN Central node" \
        -- tls_cluster_central_list_certificates
    bats_test_function \
        --description "List certificates on OVN Chassis node" \
        -- tls_cluster_chassis_list_certificates
    bats_test_function \
        --description "Reissue individual certificates on OVN Central node" \
        -- tls_cluster_central_reissue_certificates
    bats_test_function \
        --description "Reissue individual certificates on OVN Chassis node" \
        -- tls_cluster_chassis_reissue_certificates
    bats_test_function \
        --description "Reissue all certificates on OVN Central node" \
        -- tls_cluster_central_reissue_all_certificates
    bats_test_function \
        --description "Reissue all certificates on OVN Chassis node" \
        -- tls_cluster_chassis_reissue_all_certificates
    bats_test_function \
        --description "Regenerate CA" \
        -- tls_cluster_regenerate_ca
    bats_test_function \
        --description "Set user-supplied CA (RSA)" \
        -- tls_cluster_set_user_ca rsa
    bats_test_function \
        --description "Set user-supplied CA (EC)" \
        -- tls_cluster_set_user_ca ec
    bats_test_function \
        --description "Set user-supplied CA (ED)" \
        -- tls_cluster_set_user_ca ed
    bats_test_function \
        --description "Automatically renew expiring CA cert managed by the MicroOVN" \
        -- tls_cluster_ca_auto_renew "auto"
    bats_test_function \
        --description "Don't renew expiring CA cert managed by the user" \
        -- tls_cluster_ca_auto_renew "user"
}

tls_cluster_central_have_tls() {
    # Ensure that OVN service are listening on ports with TLS enabled
    local ports="6641 6642 6643 6644"

    for container in $CENTRAL_CONTAINERS; do
        local ip_addr=""
        ip_addr=$(microovn_get_cluster_address "$container")
        for port in $ports; do
            echo "# Checking port $port on $container"
            verify_service_cert "$container" "$ip_addr" "$port"
        done
    done
}

tls_cluster_certificates_valid() {
    # Validate certificate files issued by MicroOVN

    for container in $CENTRAL_CONTAINERS; do
        verify_central_cert_files "$container"
    done

    for container in $CHASSIS_CONTAINERS; do
        verify_chassis_cert_files "$container"
    done
}

tls_cluster_central_list_certificates() {
    # Ensure that expected certificates are listed in the output of the 'microovn certificates list'
    # command.
    local container=""
    container=$(echo "$CENTRAL_CONTAINERS" | awk '{print $1;}')
    local expected_output='{
  "ca": {
    "cert": "/var/snap/microovn/common/data/pki/cacert.pem",
    "auto_renew": true
  },
  "ovnnb": {
    "cert": "/var/snap/microovn/common/data/pki/ovnnb-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/ovnnb-privkey.pem"
  },
  "ovnsb": {
    "cert": "/var/snap/microovn/common/data/pki/ovnsb-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/ovnsb-privkey.pem"
  },
  "ovn-northd": {
    "cert": "/var/snap/microovn/common/data/pki/ovn-northd-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/ovn-northd-privkey.pem"
  },
  "ovn-controller": {
    "cert": "/var/snap/microovn/common/data/pki/ovn-controller-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/ovn-controller-privkey.pem"
  },
  "client": {
    "cert": "/var/snap/microovn/common/data/pki/client-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/client-privkey.pem"
  }
}'
    run lxc_exec "$container" "microovn certificates list --format json | jq"
    assert_success
    assert_output "$expected_output"

}

tls_cluster_chassis_list_certificates() {
    # Ensure that expected certificates are listed in the output of the 'microovn certificates list'
    # command.
    local container=""
    container=$(echo "$CHASSIS_CONTAINERS" | awk '{print $1;}')
    local expected_output='{
  "ca": {
    "cert": "/var/snap/microovn/common/data/pki/cacert.pem",
    "auto_renew": true
  },
  "ovnnb": null,
  "ovnsb": null,
  "ovn-northd": null,
  "ovn-controller": {
    "cert": "/var/snap/microovn/common/data/pki/ovn-controller-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/ovn-controller-privkey.pem"
  },
  "client": {
    "cert": "/var/snap/microovn/common/data/pki/client-cert.pem",
    "key": "/var/snap/microovn/common/data/pki/client-privkey.pem"
  }
}'
    run lxc_exec "$container" "microovn certificates list --format json | jq"
    assert_success
    assert_output "$expected_output"

}

tls_cluster_central_reissue_certificates() {
    # Ensure that MicroOVN is capable of individually re-issuing certificates used on OVN central nodes
    local container=""
    container=$(echo "$CENTRAL_CONTAINERS" | awk '{print $1;}')
    declare -A services=(\
        ["client"]=$CLIENT_CERT_PATH\
        ["ovnnb"]=$OVN_NB_CERT_PATH\
        ["ovnsb"]=$OVN_SB_CERT_PATH\
        ["ovn-controller"]=$CONTROLLER_CERT_PATH\
        ["ovn-northd"]=$NORTHD_CERT_PATH\
    )

    for service in "${!services[@]}"; do
        echo "# ($container) Reissuing certificate for $service"
        local cert_path="${services[$service]}"
        local old_hash=""
        local new_hash=""

        old_hash=$(get_cert_fingerprint "$container" "$cert_path")
        run reissue_certificate "$container" "$service"
        new_hash=$(get_cert_fingerprint "$container" "$cert_path")

        assert_success
        assert [ "$old_hash" != "$new_hash" ]
    done

    verify_central_cert_files "$container"
}

tls_cluster_chassis_reissue_certificates() {
    # Ensure that MicroOVN is capable of individually re-issuing certificates used on OVN chassis nodes
    local container=""
    container=$(echo "$CHASSIS_CONTAINERS" | awk '{print $1;}')
    declare -A enabled_services=(\
        ["client"]=$CLIENT_CERT_PATH\
        ["ovn-controller"]=$CONTROLLER_CERT_PATH\
    )

    declare -A disabled_services=(\
        ["ovnnb"]=$OVN_NB_CERT_PATH\
        ["ovnsb"]=$OVN_SB_CERT_PATH\
        ["ovn-northd"]=$NORTHD_CERT_PATH\
    )

    for service in "${!enabled_services[@]}"; do
        # Ensure that certificates for enabled services can be refreshed
        echo "# ($container) Reissuing certificate for $service"
        local cert_path="${enabled_services[$service]}"
        local old_hash=""
        local new_hash=""

        old_hash=$(get_cert_fingerprint "$container" "$cert_path")
        run reissue_certificate "$container" "$service"
        new_hash=$(get_cert_fingerprint "$container" "$cert_path")

        assert_success
        assert [ "$old_hash" != "$new_hash" ]
    done


    for service in "${!disabled_services[@]}"; do
        # Ensure that certificates for disabled services can not be refreshed
        echo "# ($container) Attempting to reissue certificate for $service. Expecting failure"
        local cert_path="${disabled_services[$service]}"

        run lxc_exec "$container" "ls $cert_path"
        assert_failure

        run reissue_certificate "$container" "$service"
        assert_failure
        assert_output -p "can't issue certificate for service '$service', service is not enabled on this member,"

        run lxc_exec "$container" "ls $cert_path"
        assert_failure
    done

    verify_chassis_cert_files "$container"
}

tls_cluster_central_reissue_all_certificates() {
    # Ensure that MicroOVN can reissue certificate using magic argument 'all'
    local container=""
    container=$(echo "$CENTRAL_CONTAINERS" | awk '{print $1;}')
    declare -A services=(\
        ["client"]=$CLIENT_CERT_PATH\
        ["ovnnb"]=$OVN_NB_CERT_PATH\
        ["ovnsb"]=$OVN_SB_CERT_PATH\
        ["ovn-controller"]=$CONTROLLER_CERT_PATH\
        ["ovn-northd"]=$NORTHD_CERT_PATH\
    )
    declare -A old_hashes=()
    local old_ca_hash=""
    local new_ca_hash=""
    old_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

    # Collect original certificate fingerprints
    for service in "${!services[@]}"; do
        local cert_path="${services[$service]}"
        old_hashes["$service"]=$(get_cert_fingerprint "$container" "$cert_path")
    done

    run lxc_exec "$container" "microovn certificates reissue all"
    assert_success

    # Verify that certificates have new fingerprints
    for service in "${!services[@]}"; do
        local cert_path="${services[$service]}"
        local new_hash=""
        local old_hash=""

        new_hash=$(get_cert_fingerprint "$container" "$cert_path")
        old_hash="${old_hashes[$service]}"

        assert [ "$old_hash" != "$new_hash" ]
    done

    # Verify that CA certificate itself did not change
    new_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")
    assert [ "$old_ca_hash" == "$new_ca_hash" ]

    verify_central_cert_files "$container"
}

tls_cluster_chassis_reissue_all_certificates() {
    # Ensure that MicroOVN does not issue certificates for disabled services when using magic argument 'all'
    # Remaining functionality of 'microovn certificates reissue all' is tested in "central" node test.
    local container=""
    container=$(echo "$CHASSIS_CONTAINERS" | awk '{print $1;}')
    declare -A disabled_services=(\
        ["ovnnb"]=$OVN_NB_CERT_PATH\
        ["ovnsb"]=$OVN_SB_CERT_PATH\
        ["ovn-northd"]=$NORTHD_CERT_PATH\
    )

    run lxc_exec "$container" "microovn certificates reissue all"
    assert_success


    for service in "${!disabled_services[@]}"; do
        # Ensure that certificates for disabled services were not created
        local cert_path="${disabled_services[$service]}"

        run lxc_exec "$container" "ls $cert_path"
        assert_failure
    done

    verify_chassis_cert_files "$container"
}

tls_cluster_regenerate_ca() {
    # Test recreation of the entire PKI. New CA should be created and then used to
    # reissue all server/client certificates
    local container=""
    container=$(echo "$TEST_CONTAINERS" | awk '{print $1;}')
    local old_ca_hash=""

    # Sample old CA certificate fingerprint from random host
    old_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

    # Trigger PKI regeneration
    run lxc_exec "$container" "microovn certificates regenerate-ca"
    assert_success

    # Sample new CA certificate fingerprint from random host
    new_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

    # Ensure that the CA actually changed
    assert [ -n "$old_ca_hash" ]
    assert [ -n "$new_ca_hash" ]
    assert_not_equal "$old_ca_hash" "$new_ca_hash"

    # Ensure that all members have new CA
    for container in $TEST_CONTAINERS; do
        local local_ca_hash=""
        local_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

        assert [ "$local_ca_hash" == "$new_ca_hash" ]
    done

    # Ensure that OVN Central nodes have certificates signed by new CA
    for container in $CENTRAL_CONTAINERS; do
        verify_central_cert_files "$container"
    done

    # Ensure that OVN Chassis nodes have certificates signed by new CA
    for container in $CHASSIS_CONTAINERS; do
        verify_chassis_cert_files "$container"
    done
}

tls_cluster_set_user_ca() {
    # Test rebuilding of the PKI from user-supplied CA. CA certificate should
    # be updated and then used to reissue all server/client certificates

    # This test expects key type (ec, ed or rsa) as a first parameter
    local key_type=$1; shift
    local container=""
    container=$(echo "$TEST_CONTAINERS" | awk '{print $1;}')

    # ensure that we are starting with automatic CA generated by the MicroOVN
    run lxc_exec "$container" "microovn certificates regenerate-ca"
    assert_success
    assert_equal "$AUTO_CA_CN" "$(get_cert_cn "$container" "$CA_CERT_PATH")"

    # Update CA from custom file
    generate_user_ca "$container" "$key_type" "$USER_CA_CRT" "$USER_CA_KEY"
    run lxc_exec "$container" "microovn certificates set-ca --cert $USER_CA_CRT --key $USER_CA_KEY"
    assert_success

    # check that the CA cert was replaced
    for container in $TEST_CONTAINERS; do
        assert_equal "$USER_CA_CN" "$(get_cert_cn "$container" "$CA_CERT_PATH")"
    done

    # Ensure that OVN Central nodes have certificates signed by the new CA
    for container in $CENTRAL_CONTAINERS; do
        verify_central_cert_files "$container"
    done

    # Ensure that OVN Chassis nodes have certificates signed by the new CA
    for container in $CHASSIS_CONTAINERS; do
        verify_chassis_cert_files "$container"
    done
}

tls_cluster_upgrade_from_version_without_ca_auto_renew() {
    # Older MicroOVN installations won't have 'ca_auto_renew' config key
    # in the database. This test ensures that both 'regenerate-ca' and
    # 'set-ca' work on older versions as expected
    local container=""
    container=$(echo "$TEST_CONTAINERS" | awk '{print $1;}')

    # Remove the key from the database
    run lxc_exec "microovn cluster sql \"DELETE from config where key='ca_auto_renew'\""
    assert_success

    # Attempt to regenerate-ca
    run lxc_exec "$container" "microovn certificates regenerate-ca"
    assert_success

    # check that the CA cert was replaced
    for container in $TEST_CONTAINERS; do
        assert_equal "$AUTO_CA_CN" "$(get_cert_cn "$container" "$CA_CERT_PATH")"
    done

    # Remove the key from the database again
    run lxc_exec "microovn cluster sql \"DELETE from config where key='ca_auto_renew'\""
    assert_success

    # Attempt to set user-supplied CA
    generate_user_ca "$container" "$key_type" "$USER_CA_CRT" "$USER_CA_KEY"
    run lxc_exec "$container" "microovn certificates set-ca --cert $USER_CA_CRT --key $USER_CA_KEY"
    assert_success

    # check that the CA cert was replaced
    for container in $TEST_CONTAINERS; do
        assert_equal "$USER_CA_CN" "$(get_cert_cn "$container" "$CA_CERT_PATH")"
    done
}

tls_cluster_ca_auto_renew() {
    # Test that the auto-refresh script renews automatically generated CA
    # when it gets near to it's expiry. At the same time, verify that the
    # script won't try to renew CA provided by the user
    local cert_type=$1; shift
    if [ -n "$SKIP_TLS_RENEW" ]; then
        skip "SKIP_TLS_RENEW is set. Skipping"
    fi
    local container
    container=$(echo "$TEST_CONTAINERS" | awk '{print $1;}')
    local refresh_timer="snap.microovn.refresh-expiring-certs.timer"
    local refresh_service="snap.microovn.refresh-expiring-certs.service"

    # Set-up CA certificate based on the requested type
    if [ "$cert_type" == "auto" ]; then
        run lxc_exec "$container" "microovn certificates regenerate-ca"
        assert_success
    elif [ "$cert_type" == "user" ]; then
        generate_user_ca "$container" "ec" "$USER_CA_CRT" "$USER_CA_KEY"
        run lxc_exec "$container" "microovn certificates set-ca --cert $USER_CA_CRT --key $USER_CA_KEY"
        assert_success
    else
        echo "# Unknown certificate type: $cert_type"
        return 1
    fi

    # Adjust container date so that the CA cert is eligible for renewal
    # (min. 10 days before expiry) and time to a window in which refresh
    # refresh script is allowed to run (02:00-02:30)
    for container in $TEST_CONTAINERS; do
        # disable systemctl timer so that we can trigger refresh manually
        lxc_exec "$container" "systemctl disable --now $refresh_timer"
        lxc_exec "$container" "timedatectl set-ntp no"
        lxc_exec "$container" "timedatectl set-time +9y360d"
        lxc_exec "$container" "timedatectl set-time 02:01:00"
    done
    export RESET_TIME="yes"

    local old_ca_hash
    local after_refresh_ca_hash

    # Sample old CA certificate fingerprint from random host
    old_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

    # Trigger refresh service
    run lxc_exec "$container" "systemctl start $refresh_service"
    assert_success

    # Sample new CA certificate fingerprint
    after_refresh_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

    # Ensure that the CA actually changed
    assert [ -n "$old_ca_hash" ]
    assert [ -n "$after_refresh_ca_hash" ]

    if [ "$cert_type" == "auto" ]; then
        # If the CA certificate is automatically managed by the MicroOVN
        # we expect it to be refreshed
        assert_not_equal "$old_ca_hash" "$after_refresh_ca_hash"
    elif [ "$cert_type" == "user" ]; then
        # If the CA certificate is managed by the user, we don't expect it
        # to be automatically refreshed
        assert_equal "$old_ca_hash" "$after_refresh_ca_hash"
    else
        echo "# Unknown certificate type: $cert_type"
        return 1
    fi

    # Ensure that all members have the expected CA
    for container in $TEST_CONTAINERS; do
        local local_ca_hash=""
        local_ca_hash=$(get_cert_fingerprint "$container" "$CA_CERT_PATH")

        assert [ "$local_ca_hash" == "$after_refresh_ca_hash" ]
    done
}

tls_cluster_register_test_functions
