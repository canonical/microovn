From 204d1382171941c379620bccc939175798c5fb05 Mon Sep 17 00:00:00 2001
From: Frode Nordahl <fnordahl@ubuntu.com>
Date: Thu, 25 Jul 2024 16:00:07 +0200
Subject: [PATCH 5/7] northd: Allow IPv6 in get_nat_addresses().

While IPv6 and NAT does not ring particularly well together in my
mind, it is a supported feature.

We need this function to allow them in a subsequent patch adding
host route exchange for NAT addresses.

Signed-off-by: Frode Nordahl <fnordahl@ubuntu.com>
---
 northd/northd.c | 23 ++++++++++++++++++-----
 1 file changed, 18 insertions(+), 5 deletions(-)

diff --git a/northd/northd.c b/northd/northd.c
index a267cd5f8..4478a245b 100644
--- a/northd/northd.c
+++ b/northd/northd.c
@@ -1149,14 +1149,16 @@ destroy_routable_addresses(struct ovn_port_routable_addresses *ra)
 
 static char **get_nat_addresses(const struct ovn_port *op, size_t *n,
                                 bool routable_only, bool include_lb_ips,
-                                const struct lr_stateful_record *);
+                                const struct lr_stateful_record *,
+                                bool allow_ipv6);
 
 static struct ovn_port_routable_addresses
 get_op_routable_addresses(struct ovn_port *op,
                           const struct lr_stateful_record *lr_stateful_rec)
 {
     size_t n;
-    char **nats = get_nat_addresses(op, &n, true, true, lr_stateful_rec);
+    char **nats = get_nat_addresses(op, &n, true, true, lr_stateful_rec,
+                                    false);
 
     if (!nats) {
         return (struct ovn_port_routable_addresses) {
@@ -2511,7 +2513,8 @@ join_logical_ports(const struct sbrec_port_binding_table *sbrec_pb_table,
 static char **
 get_nat_addresses(const struct ovn_port *op, size_t *n, bool routable_only,
                   bool include_lb_ips,
-                  const struct lr_stateful_record *lr_stateful_rec)
+                  const struct lr_stateful_record *lr_stateful_rec,
+                  bool allow_ipv6)
 {
     size_t n_nats = 0;
     struct eth_addr mac;
@@ -2534,6 +2537,7 @@ get_nat_addresses(const struct ovn_port *op, size_t *n, bool routable_only,
     for (size_t i = 0; i < op->od->nbr->n_nat; i++) {
         const struct nbrec_nat *nat = op->od->nbr->nat[i];
         ovs_be32 ip, mask;
+        struct in6_addr ip6, mask6;
 
         if (routable_only &&
             (!strcmp(nat->type, "snat") ||
@@ -2544,7 +2548,15 @@ get_nat_addresses(const struct ovn_port *op, size_t *n, bool routable_only,
         char *error = ip_parse_masked(nat->external_ip, &ip, &mask);
         if (error || mask != OVS_BE32_MAX) {
             free(error);
-            continue;
+            if (allow_ipv6) {
+                error = ipv6_parse_masked(nat->external_ip, &ip6, &mask6);
+                if (error || ipv6_count_cidr_bits(&mask6) != 128) {
+                    free(error);
+                    continue;
+                }
+            } else {
+                continue;
+            }
         }
 
         /* Not including external IP of NAT rules whose gateway_port is
@@ -3888,7 +3900,8 @@ sync_pb_for_lsp(struct ovn_port *op,
                         lr_stateful_table, op->peer->od->index);
                 }
                 nats = get_nat_addresses(op->peer, &n_nats, false,
-                                         include_lb_vips, lr_stateful_rec);
+                                         include_lb_vips, lr_stateful_rec,
+                                         false);
             }
         } else if (nat_addresses && (chassis || l3dgw_ports)) {
             struct lport_addresses laddrs;
-- 
2.43.0

