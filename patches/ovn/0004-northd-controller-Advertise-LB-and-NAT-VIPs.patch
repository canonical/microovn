From 4826145084f8cbbdb91a8363824e70482bc6edca Mon Sep 17 00:00:00 2001
From: Martin Kalcok <martin.kalcok@canonical.com>
Date: Fri, 20 Dec 2024 13:40:20 +0100
Subject: [Patch ovn 3/3] northd,controller: Advertise LB and NAT VIPs.
To: dev@openvswitch.org

Building on top of proposed patch series to northd [0],
controller [1] and ovs [2], this change allows to advertise
LB VIPs and NAT external IPs.

Signed-off-by: Martin Kalcok <martin.kalcok@canonical.com>
---
 northd/en-advertised-route-sync.c | 11 ++++
 northd/inc-proc-northd.c          |  4 ++
 northd/northd.c                   | 93 ++++++++++++++++++++++++++++++-
 northd/northd.h                   |  4 ++
 4 files changed, 111 insertions(+), 1 deletion(-)

diff --git a/northd/en-advertised-route-sync.c b/northd/en-advertised-route-sync.c
index 065c73861..b6786b3af 100644
--- a/northd/en-advertised-route-sync.c
+++ b/northd/en-advertised-route-sync.c
@@ -421,9 +421,20 @@ advertised_route_table_sync(
                                         "dynamic-routing-static")) {
             continue;
         }
+        if (route->source == ROUTE_SOURCE_NAT &&
+                !smap_get_bool(&route->out_port->nbrp->options,
+                               "redistribute-nat", false)) {
+                continue;
+        }
+        if (route->source == ROUTE_SOURCE_LB &&
+                !smap_get_bool(&route->out_port->nbrp->options,
+                               "redistribute-lb-vips", false)) {
+                continue;
+        }
 
         char *ip_prefix = normalize_v46_prefix(&route->prefix,
                                                route->plen);
+
         ar_sync_to_sb(ovnsb_txn, &sync_routes,
                          route->od->sb,
                          route->out_port->sb,
diff --git a/northd/inc-proc-northd.c b/northd/inc-proc-northd.c
index ab500a86a..36e1d9993 100644
--- a/northd/inc-proc-northd.c
+++ b/northd/inc-proc-northd.c
@@ -262,6 +262,10 @@ void inc_proc_northd_init(struct ovsdb_idl_loop *nb,
     engine_add_input(&en_routes, &en_bfd, NULL);
     engine_add_input(&en_routes, &en_northd,
                      routes_northd_change_handler);
+    engine_add_input(&en_routes, &en_lr_nat,
+                     NULL);
+    engine_add_input(&en_routes, &en_lb_data,
+                     NULL);
 
     engine_add_input(&en_bfd_sync, &en_bfd, NULL);
     engine_add_input(&en_bfd_sync, &en_nb_bfd, NULL);
diff --git a/northd/northd.c b/northd/northd.c
index 23b0769fe..f5937a6a8 100644
--- a/northd/northd.c
+++ b/northd/northd.c
@@ -4071,6 +4071,12 @@ sync_pb_for_lrp(struct ovn_port *op,
         if (smap_get_bool(&op->od->nbr->options, "dynamic-routing", false)) {
             smap_add(&new, "dynamic-routing", "true");
         }
+        if (smap_get_bool(&op->nbrp->options, "redistribute-nat", false)) {
+            smap_add(&new, "redistribute-nat", "true");
+        }
+        if (smap_get_bool(&op->nbrp->options, "redistribute-lb-vips", false)) {
+            smap_add(&new, "redistribute-lb-vips", "true");
+        }
         const char *ifname = smap_get(&op->nbrp->options,
                                       "dynamic-routing-ifname");
         if (ifname) {
@@ -11435,6 +11441,85 @@ parsed_routes_add_connected(const struct ovn_datapath *od,
     }
 }
 
+static void
+parsed_routes_add_nat(const struct ovn_datapath *od,
+                      const struct ovn_port *op,
+                      struct hmap *routes)
+{
+    if (!op->nbrp || !smap_get_bool(&op->nbrp->options, "redistribute-nat", false)) {
+        return;
+    }
+
+    size_t n_nats = 0;
+    char **nats = NULL;
+    nats = get_nat_addresses(op, &n_nats, false, false, NULL, true);
+
+    for (size_t i = 0; i < n_nats; i++){
+        struct lport_addresses *laddrs = xzalloc(sizeof *laddrs);
+        int ofs = 0;
+        extract_addresses(nats[i], laddrs, &ofs);
+        for (int j = 0; j < laddrs->n_ipv4_addrs; j++){
+            struct ipv4_netaddr *addr = &laddrs->ipv4_addrs[j];
+            struct in6_addr prefix;
+            ip46_parse(addr->network_s, &prefix);
+
+            parsed_route_add(od, NULL, &prefix, addr->plen,
+                             false, addr->addr_s, op,
+                             0, false,
+                             false, NULL, ROUTE_SOURCE_NAT,
+                             &op->nbrp->header_, routes);
+        }
+        destroy_lport_addresses(laddrs);
+        free(nats[i]);
+    }
+    free(nats);
+}
+
+static void
+advertise_lb_route(const struct ovn_datapath *od,
+                  const struct ovn_port *op,
+                  const char *ip_s,
+                  struct hmap *routes){
+    struct in6_addr prefix;
+    ip46_parse(ip_s, &prefix);
+
+    parsed_route_add(od, NULL, &prefix, 32,
+                     false, ip_s, op,
+                     0, false,
+                     false, NULL, ROUTE_SOURCE_LB,
+                     &op->nbrp->header_, routes);
+
+}
+static void
+parsed_routes_add_lb(const struct ovn_datapath *od,
+                     const struct ovn_port *op,
+                     struct hmap *routes)
+{
+    if (!op->nbrp || !smap_get_bool(&op->nbrp->options, "redistribute-lb-vips", false)) {
+        return;
+    }
+
+    struct smap_node *node;
+    for (size_t i = 0; i < od->nbr->n_load_balancer; i++) {
+        SMAP_FOR_EACH (node, &od->nbr->load_balancer[i]->vips) {
+            if (find_lport_address(&op->lrp_networks, node->key)) {
+                advertise_lb_route(od, op, node->key, routes);
+            }
+        }
+    }
+
+    for (size_t i = 0; i < od->nbr->n_load_balancer_group; i++) {
+        struct nbrec_load_balancer_group *lb_group = od->nbr->load_balancer_group[i];
+        for (size_t j = 0; j < lb_group->n_load_balancer; j++) {
+            SMAP_FOR_EACH (node, &lb_group->load_balancer[j]->vips) {
+                if (find_lport_address(&op->lrp_networks, node->key)) {
+                    advertise_lb_route(od, op, node->key, routes);
+                }
+            }
+        }
+    }
+}
+
 void
 build_parsed_routes(const struct ovn_datapath *od, const struct hmap *lr_ports,
                      const struct hmap *bfd_connections, struct hmap *routes,
@@ -11457,6 +11542,8 @@ build_parsed_routes(const struct ovn_datapath *od, const struct hmap *lr_ports,
     const struct ovn_port *op;
     HMAP_FOR_EACH (op, dp_node, &od->ports) {
         parsed_routes_add_connected(od, op, routes);
+        parsed_routes_add_nat(od, op, routes);
+        parsed_routes_add_lb(od, op, routes);
     }
 
     HMAP_FOR_EACH_SAFE (pr, key_node, routes) {
@@ -11638,6 +11725,8 @@ route_source_to_offset(enum route_source source)
 {
     switch (source) {
         case ROUTE_SOURCE_CONNECTED:
+        case ROUTE_SOURCE_NAT:
+        case ROUTE_SOURCE_LB:
             return ROUTE_PRIO_OFFSET_CONNECTED;
         case ROUTE_SOURCE_STATIC:
             return ROUTE_PRIO_OFFSET_STATIC;
@@ -13915,7 +14004,9 @@ build_route_flows_for_lrouter(
     struct parsed_route *route;
     HMAP_FOR_EACH_WITH_HASH (route, key_node, uuid_hash(&od->key),
                              parsed_routes) {
-        if (route->source == ROUTE_SOURCE_CONNECTED) {
+        if (route->source == ROUTE_SOURCE_CONNECTED ||
+                route->source == ROUTE_SOURCE_NAT ||
+                route->source == ROUTE_SOURCE_LB) {
             unique_routes_add(&unique_routes, route);
             continue;
         }
diff --git a/northd/northd.h b/northd/northd.h
index 3bc6f6f04..117b7421f 100644
--- a/northd/northd.h
+++ b/northd/northd.h
@@ -702,6 +702,10 @@ enum route_source {
     ROUTE_SOURCE_CONNECTED,
     /* The route is derived from a northbound static route entry. */
     ROUTE_SOURCE_STATIC,
+    /* Host route generated from NAT's external IP. */
+    ROUTE_SOURCE_NAT,
+    /* Host route generated from LB's external IP. */
+    ROUTE_SOURCE_LB,
     /* the route is learned by an ovn-controller */
     ROUTE_SOURCE_LEARNED,
 };
-- 
2.43.0

